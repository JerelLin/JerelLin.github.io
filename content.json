{"meta":{"title":"秋天该很好 你若尚在场","subtitle":null,"description":"秋天该很好 你若尚在场","author":"晚秋","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2016-11-06T01:20:51.029Z","updated":"2016-11-05T15:55:16.306Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-11-06T01:19:47.104Z","updated":"2016-11-05T15:55:16.308Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记、基于react-router的单页应用","slug":"记、基于react-router的单页应用 ","date":"2016-04-29T02:39:00.000Z","updated":"2016-11-06T09:13:19.257Z","comments":true,"path":"2016/04/29/记、基于react-router的单页应用 /","link":"","permalink":"http://yoursite.com/2016/04/29/记、基于react-router的单页应用 /","excerpt":"","text":"现在用react写单页应用基本上都是用react-router做前端路由了吧！最近在使用react-router的过程中遇到了不少问题，在这里总结一下。 浏览器url react-router默认提供的history是 createHashHistory ，即它用到的是 URL 中的 hash（#）部分去创建形如 example.com/#/some/path 的路由，所以你会看到url多了类似 _key=s1gvrm 的 query，这真的很难看。而且这也不是官方在实际生产应用中所推荐的。要改变这种情况的话，我们需要去使用 createBrowserHistory ，在我们的代码中引入history，并在Router组件处调用 createBrowserHistory 方法即可。 123456789101112131415161718192021import React from \"react\";import ReactDOM from \"react-dom\";import createBrowserHistory from \"history/lib/createBrowserHistory\"import &#123; Router,Route,Link,browserHistory,IndexRoute,IndexLink &#125; from \"react-router\";class App extends React.Component&#123; render()&#123; return( ... ); &#125;&#125;;ReactDOM.render( ( &lt;Router history=&#123; createBrowserHistory() &#125;&gt; ... &lt;/Router&gt; ),document.getElementById(\"app\") ); 其实关于url还有许多的细节，因为react-router本身就是构建于history之上的。单页应用的url只不过是针对于react- router的一个标示而已，界面间的跳转全然由react-router决定，react-router检查当前url随后渲染匹配的路由组件，所以在 浏览器上直接输入一个正确的非根路径你甚至只能看到404。 组件通信 这是一个用react写代码永远都绕不开的话题。react-router是基于react开发的，所以它的每一个route都是一个组件。路由组 件间的通信一般借由Link来实现，而根据路由参数的不同，还可以分成两种。这个很容易理解，因为这两种方式和我们平时写的后台路由并没有什么太大差别。 1 param，param通过/:param的方式传递。 比如说我们现在有一个显示消息列表的路由组件，我们需要在点击每一个消息的时候能跳转到显示被点击消息详情的路由组件。这个时候我们消息详情路由组件可以是这样定义的： 在消息列表路由组件那里我们让每一条消息都是这样的一个Link： 1&lt;Link to=&#123; `News_detail/$&#123; element.timestamp &#125;` &#125; &gt;&#123; element.news &#125;&lt;/Link&gt; 这样的话我们的消息详情组件就能通过 this.props.params 获取到消息列表组件传递而来的 element.timestamp 参数了。 2 query 1&lt;Link to=\"/Activity_Publish\" query=&#123;&#123; timestamp : element.timestamp &#125;&#125;&gt;编辑&lt;/Link&gt; 在 /Activity_Publish 映射的路由组件里面可以通过 12var &#123; query &#125; = this.props.location;var timestamp = query.timestamp; 获取到query参数。 相对于param，局限性更小，你可以根据需要传递更多的参数，只不过有点类似于get请求，传递的参数会附带在url后面，看起来有点丑，而且几乎无隐蔽性可言。 3 state 不过还是有第三种方式的，就是state，这种方式借助了location 对象，location 对象可以简单的认为是 url 的对象形式表示，这里要提的是 location.state，每个 URL 都会对应一个 state 对象，你可以在对象里存储数据，但这个数据却不会出现在 url 中。实际上，数据被存在了 sessionStorage 中，但是因为这种处理方式不是将数据附加与url之后的，一旦重新刷新页面，会造成数据的丢失。 1&lt;Link to=\"/Activity_Publish\" state=&#123;&#123; timestamp : element.timestamp &#125;&#125;&gt;编辑&lt;/Link&gt; 按需加载 react-router协同webpack的使用可以实现组件的按需加载，而且 这种按需加载完全是异步的，这点特别酷炫，你不再需要一口气加载那么大的js文件，即使里面包含着许多用户甚至都不会使用到的web组件。你可以只根据需 要加载用户浏览的那些组件，这个举措将会帮你大大的降低首屏渲染的时间。 实现这个功能很简单，比如在一开始你的路由是这样子的： 123456789101112131415161718...import News_detail from \"./marriage_component/activity/news_detail.jsx\";...class App extends React.Component&#123; render()&#123; ... &#125;&#125;;ReactDOM.render( ( &lt;Router history=&#123; createBrowserHistory() &#125;&gt; &lt;Route path=\"/marriage_app\" component=&#123; App &#125;&gt; ... &lt;Route path=\"/marriage_app/News_detail/:news_id\" component=&#123; News_detail &#125;/&gt; ... 把它改成这样就行了： 12345678910111213141516171819202122...//import News_detail from \"./marriage_component/activity/news_detail.jsx\";...class App extends React.Component&#123; render()&#123; ... &#125;&#125;;ReactDOM.render( ( &lt;Router history=&#123; createBrowserHistory() &#125;&gt; &lt;Route path=\"/marriage_app\" component=&#123; App &#125;&gt; ... &lt;Route path=\"/marriage_app/News_detail/:news_id\" getComponent=&#123; (nextState, callback) =&gt;&#123; require.ensure( [ ], (require) =&gt; &#123; callback(null, require(\"./marriage_component/activity/news_detail\").default) &#125;) &#125; &#125;/&gt; ... 一开始的组件不再需要被导入，webpack会帮你在需要的时候引入它。 这种前后端分离的模式真的很赞，但似乎对SEO并不是很友好。如果真的需要SEO，又追求于实现前后端的真正解耦，是不是以Nodejs为中间层的架构模式会成为一种解决方案呢？","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"冒泡排序算法可视化","slug":" 冒泡排序算法可视化 ","date":"2016-04-01T13:43:00.000Z","updated":"2016-11-06T09:15:53.761Z","comments":true,"path":"2016/04/01/ 冒泡排序算法可视化 /","link":"","permalink":"http://yoursite.com/2016/04/01/ 冒泡排序算法可视化 /","excerpt":"","text":"在百度前端技术学院的任务列表那里看到了有一个任务是要求用javascript实现可视化的排序算法，感觉很有趣，就稍微研究了一下. 冒泡排序原理 冒泡排序我们应该都不陌生吧？很简单的两个for循环就可以实现了，其基本原理是：在一开始的时候，比较第一第二个数，如果如果第一个数比第二个数大的话则交换二者位置，在比较第二个和第三个数，同样的如果第二个数比第三个数大的话，则交换二者位置，如此重复，所以一趟比较下来就能筛选出最大的一个数并把它排在最后的位置，又因为一个for循环的话只能选出一个最大的数，而我们还需要选出第二大、第三大…到最小的数，所以还需要加一个for循环才能实现我们的目标。用javascript实现就是：123456789101112131415161718/*冒泡排序*/function bubbleSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125;; var temp=0; for(var i=0; i&lt;arr.length; i++)&#123; for(var j=0; j&lt;arr.length-i-1; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125;; &#125;; &#125;; return arr;&#125;； 可视化原理 接下来就是要用可视化的方式把排序的过程展现出来了。我们可以用这两种方法去实现它： 1 排序的每一步结束后，我们让程序暂停一下运行（javascript没有sleep函数，我们需要自己去实现它），这样子的话，在我们看来排序的过程就是一步一步的进行的，就不会一瞬间就排序结束了。 2 我们可以通过维护一个数组，把每一次排序之后的数组保存起来，在排序算法结束之后，我们再把保存的每一个数组依次绘制出来。我这里的实现用的就是这种方法。 12345678910111213141516171819202122232425var snapshots=[]; //快照集合var timer=null; //定时 var arr=[50,21,5,89,13,35,69,44,60,15,51,80,55,71]; //排序数组/*冒泡排序*/function bubbleSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125;; var temp=0; for(var i=0; i&lt;arr.length; i++)&#123; for(var j=0; j&lt;arr.length-i-1; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; snapshots.push(JSON.parse(JSON.stringify(arr))); //&lt;=记录下快照 &#125;; &#125;; &#125;; return arr;&#125;;Array.prototype.bubbleSort=function()&#123; return bubbleSort(this);&#125; 我们设置一个snapshots数组变量，用于记录下每一次排序之后数组的快照，等排序结束之后，我们就能得到一组记录下完整的排序过程的数组的快照了，这个时候我们再按照一定的时间间隔依次把这些快照绘制出来，就能实现出排序过程的可视化了。 123456789101112131415161718192021222324252627282930/*绘图*/function painting()&#123; var container=document.getElementById(\"container\"); var bars=[].slice.call( document.querySelectorAll(\".bar\") ); //将所有bar元素的集合转换为数组对象 for(var i=0;i&lt;arr.length;i++)&#123; if(bars.length!=arr.length)&#123; var bar=document.createElement(\"div\"); bar.className=\"bar\"; container.appendChild(bar); &#125;else&#123; break; //当bar的数量等于数组的长度时，停止创建bar元素 &#125;; &#125;; var snapshot=snapshots.shift() || []; //取出快照记录数组中的第一条记录 console.log(snapshot); if(snapshot.length!=0)&#123; for(var i=0; i&lt;bars.length; i++)&#123; bars[i].innerHTML=snapshot[i]; bars[i].style.height=snapshot[i]*5+\"px\"; bars[i].style.left=(i+1)*50+\"px\"; &#125;; &#125;else&#123; clearInterval(timer); //绘制结束 return; &#125;;&#125;;arr.bubbleSort(); //排序timer=setInterval(painting,200); //定时绘制","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"closure！","slug":" closure！ ","date":"2016-03-29T10:38:00.000Z","updated":"2016-11-06T08:54:11.722Z","comments":true,"path":"2016/03/29/ closure！ /","link":"","permalink":"http://yoursite.com/2016/03/29/ closure！ /","excerpt":"","text":"总结一下闭包。 闭包的定义：当一个内部函数被其外部函数之外的变量所引用时，就形成了一个闭包。 一个最简单的闭包：1234567891011function A()&#123; var count=0; return function()&#123; count++; console.log(count); &#125;;&#125;var B=A();B(); //1 B(); //2B(); //3 important！=&gt;javascript的GC机制： 在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收，否则这个对象一直会保存在内存中。 所以我们就可以理解为什么在上述代码中，A函数明明已经被返回退出执行了，变量count却没有被回收（count一直在原来的基础上增加1，而不是每一次都重新从0开始再增加1），因为匿名函数（闭包）被返回赋予变量B，即被变量B所引用（在javascript中对象的赋值是引用传递），故这个匿名函数不会GC回收，同时变量count被匿名函数所引用，所以变量count亦不会被回收，因此变量count才会一直会保存于内存中。 闭包的特性js分全局作用域和函数作用域（没有块级作用域，if语句或for循环语句里面定义的变量在外部可以被访问）。函数作用域里可以访问到全局，通过一个叫作用域链（函数内部作用域=&gt;父级函数的作用域=&gt;父级函数的父级函数的作用域…=&gt;全局作用域）的东西。但全局怎么访问函数呢？我们可以通过在函数里面返回一个函数(闭包)，就可以在全局访问到函数里的数据了（在上面代码中，我们在全局里访问到了A函数的count变量）。不过闭包能访问到父级函数里面的数据说明父级函数里的数据一直存在内存中(一直被闭包所引用着)，而没有被GC所回收，这就会导致内存一直被占着。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"Nodejs爬虫进阶=>异步并发控制","slug":"Nodejs爬虫进阶 -- 异步并发控制","date":"2016-02-06T04:21:00.000Z","updated":"2016-11-06T08:48:41.650Z","comments":true,"path":"2016/02/06/Nodejs爬虫进阶 -- 异步并发控制/","link":"","permalink":"http://yoursite.com/2016/02/06/Nodejs爬虫进阶 -- 异步并发控制/","excerpt":"","text":"之前写了个现在看来很不完美的小爬虫，很多地方没有处理好，比如说在知乎点开一个问题的时候，它的所有回答并不是全部加载好了的，当你拉到回答的尾部时，点击加载更多，回答才会再加载一部分，所以说如果直接发送一个问题的请求链接，取得的页面是不完整的。还有就是我们通过发送链接下载图片的时候，是一张一张来下的，如果图片数量太多的话，真的是下到你睡完觉它还在下，而且我们用nodejs写的爬虫，却竟然没有用到nodejs最牛逼的异步并发的特性，太浪费了啊。 思路 这次的的爬虫是上次那个的升级版，不过呢，上次那个虽然是简单，但是很适合新手学习啊。这次的爬虫代码在我的github上可以找到=&gt;https://github.com/KellyLy/NodeSpider。 整个爬虫的思路是这样的：在一开始我们通过请求问题的链接抓取到部分页面数据，接下来我们在代码中模拟ajax请求截取剩余页面的数据，当然在这里也是可以通过异步来实现并发的，对于小规模的异步流程控制，可以用这个模块=&gt;eventproxy，但这里我就没有用啦！我们通过分析获取到的页面从中截取出所有图片的链接，再通过异步并发来实现对这些图片的批量下载。 抓取页面初始的数据很简单啊，这里就不做多解释啦 123456789101112131415161718192021/*获取首屏所有图片链接*/var getInitUrlList=function()&#123; request.get(\"https://www.zhihu.com/question/34937418\") .end(function(err,res)&#123; if(err)&#123; console.log(err); &#125;else&#123; var $=cheerio.load(res.text); var answerList=$(\".zm-item-answer\"); answerList.map(function(i,answer)&#123; var images=$(answer).find('.zm-item-rich-text img'); images.map(function(i,image)&#123; photos.push($(image).attr(\"src\")); &#125;); &#125;); console.log(\"已成功抓取\"+photos.length+\"张图片的链接\"); getIAjaxUrlList(20); &#125; &#125;);&#125; 模拟ajax请求获取完整页面接下来就是怎么去模拟点击加载更多时发出的ajax请求了，去知乎看一下吧！ 有了这些信息，就可以来模拟发送相同的请求来获得这些数据啦。 123456789101112131415161718192021222324252627282930313233/*每隔100毫秒模拟发送ajax请求，并获取请求结果中所有的图片链接*/var getIAjaxUrlList=function(offset)&#123; request.post(\"https://www.zhihu.com/node/QuestionAnswerListV2\") .set(config) .send(\"method=next&amp;params=%7B%22url_token%22%3A34937418%2C%22pagesize%22%3A20%2C%22offset%22%3A\" +offset+ \"%7D&amp;_xsrf=98360a2df02783902146dee374772e51\") .end(function(err,res)&#123; if(err)&#123; console.log(err); &#125;else&#123; var response=JSON.parse(res.text);/*想用json的话对json序列化即可，提交json的话需要对json进行反序列化*/ if(response.msg&amp;&amp;response.msg.length)&#123; var $=cheerio.load(response.msg.join(\"\"));/*把所有的数组元素拼接在一起，以空白符分隔，不要这样join()，它会默认数组元素以逗号分隔*/ var answerList=$(\".zm-item-answer\"); answerList.map(function(i,answer)&#123; var images=$(answer).find('.zm-item-rich-text img'); images.map(function(i,image)&#123; photos.push($(image).attr(\"src\")); &#125;); &#125;); setTimeout(function()&#123; offset+=20; console.log(\"已成功抓取\"+photos.length+\"张图片的链接\"); getIAjaxUrlList(offset); &#125;,100); &#125;else&#123; console.log(\"图片链接全部获取完毕，一共有\"+photos.length+\"条图片链接\"); // console.log(photos); return downloadImg(50); &#125; &#125; &#125;);&#125; 在代码中post这条请求 https://www.zhihu.com/node/QuestionAnswerListV2, 把原请求头和请求参数复制下来，作为我们的请求头和请求参数，superagent的set方法可用来设置请求头，send方法可以用来发送请求参数。我们把请求参数中的offset初始为20，每隔一定时间offset再加20，再重新发送请求，这样就相当于我们每隔一定时间发送了一条ajax请求，获取到最新的20条数据，每获取到了数据，我们再对这些数据进行一定的处理，让它们变成一整段的html，便于后面的提取链接处理。 异步并发控制下载图片再获取完了所有的图片链接之后，即判定response.msg为空时，我们就要对这些图片进行下载了，不可能一条一条下对不对，因为如你所看到的，我们的图片足足有 没错，2万多张，不过幸好nodejs拥有神奇的单线程异步特性，我们可以同时对这些图片进行下载。但这个时候问题来了，听说同时发送请求太多的话会被网站封ip哒！这是真的吗？我不知道啊，没试过，因为我也不想去试(￣ー￣〃)，所以这个时候我们就需要对异步并发数量进行一些控制了。 在这里用到了一个神奇的模块=&gt;async，它不仅能帮我们拜托难以维护的回调金字塔恶魔，还能轻松的帮我们进行异步流程的管理。具体看文档啦，因为我自己也不怎么会用，这里就只用到了一个强大的async.mapLimit方法。真的很厉害哦。 12345678910111213141516171819202122232425262728293031323334353637383940414243var requestAndwrite=function(url,callback)&#123; request.get(url).end(function(err,res)&#123; if(err)&#123; console.log(err); console.log(\"有一张图片请求失败啦...\"); &#125;else&#123; var fileName=path.basename(url); fs.writeFile(\"./img1/\"+fileName,res.body,function(err)&#123; if(err)&#123; console.log(err); console.log(\"有一张图片写入失败啦...\"); &#125;else&#123; console.log(\"图片下载成功啦\"); callback(null,\"successful !\"); /*callback貌似必须调用，第二个参数将传给下一个回调函数的result，result是一个数组*/ &#125; &#125;); &#125; &#125;);&#125;var downloadImg=function(asyncNum)&#123; /*有一些图片链接地址不完整没有“http:”头部,帮它们拼接完整*/ for(var i=0;i&lt;photos.length;i++)&#123; if(photos[i].indexOf(\"http\")===-1)&#123; photos[i]=\"http:\"+photos[i]; &#125; &#125; console.log(\"即将异步并发下载图片，当前并发数为:\"+asyncNum); async.mapLimit(photos,asyncNum,function(photo,callback)&#123; console.log(\"已有\"+asyncNum+\"张图片进入下载队列\"); requestAndwrite(photo,callback); &#125;,function(err,result)&#123; if(err)&#123; console.log(err); &#125;else&#123; // console.log(result);&lt;=会输出一个有2万多个“successful”字符串的数组 console.log(\"全部已下载完毕！\"); &#125; &#125;);&#125;; 先看这里=&gt; mapLimit方法的第一个参数photos是所有图片链接的数组，也是我们并发请求的对象，asyncNum是限制并发请求的数量，如果没有这个参数的话，将会有同时两万多条请求发送过去，嗯，你的ip就会被成功的封掉，但当我们有这个参数时，比如它的值是10，则它一次就只会帮我们从数组中取10条链接，执行并发的请求，这10条请求都得到响应后，再发送下10条请求。告诉泥萌，并发到同时100条没有事的，下载速度超级快，再往上就不知道咯，你们来告诉我… 结尾 哦哦~，明天就是除夕了~","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"一个用 react+nodejs 实现的笔记本小应用","slug":"一个用react+nodejs实现的笔记本小应用","date":"2016-02-01T15:38:00.000Z","updated":"2016-11-06T08:32:53.271Z","comments":true,"path":"2016/02/01/一个用react+nodejs实现的笔记本小应用/","link":"","permalink":"http://yoursite.com/2016/02/01/一个用react+nodejs实现的笔记本小应用/","excerpt":"","text":"寒假回家产品经理一直叮嘱着要继续做学校团队的辣个项目，但是…，我到现在一点都还没做，而且还销声匿迹躲了起来藏了几天，是的我干了票大的，偷偷的在项目上用了一些现在比较潮流的新技术，所以这几天一直在偷偷摸摸的做一些不相干的东西，不知道产品经理知道了会不会砍我… 现在这个就是我昨天做的又一个不务正业的小东西 这里应该有一段严肃的说明 -应用功能 1 添加笔记 2 删除笔记 3 显示和隐藏表单 好吧⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄.我承认这功能确实是太简单了… =&gt;github完整版：https://github.com/KellyLy/react-note 献上各种效果图(因为这样博客看起来会比较长⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄)： 实现思路 技术上前端用的是react框架+webpack作为构建工具，后台用的nodejs和mongodb。 总的实现思路是这样的：利用了react当state改变会自动调用this.render方法重新渲染视图的特点，我在整个应用组件didMounted的时候，通过ajax从数据库拿到notes笔记记录把它们和state绑定在一起，所以当数据改变的时候state也会改变，state一改变视图重新被渲染，所以在添加删除笔记的时候页面表现的很流畅，你不需要显式的去进行各种dom操作，因为这个过程react通过虚拟dom帮我们解决了，这也是我觉得react做的非常棒的地方。 源码 页面被拆分为多个子组件和一个包含这些子组件的父组件。 这是父组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113\"use strict\";import React from \"react\";import ReactDOM from \"react-dom\";import $ from \"./jquery.min.js\";import Notes_header from \"./Notes_header.jsx\";import Notes_form from \"./Notes_form.jsx\";import Notes_list from \"./Notes_list.jsx\";class Notes extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; notes : [], formDisplayed : false &#125;; &#125; componentDidMount()&#123; $.ajax(&#123; url : \"/init\", type : \"get\", dataType : \"json\", cache : false, success : function(notes)&#123; /*notes是从数据库读取到的笔记数组*/ // console.log(\"请求成功了！！但是...数据呢？...\"); notes=this.notesSort(notes); this.setState(&#123; notes: notes &#125;); // console.log(this.state.notes); &#125;.bind(this), error : function()&#123; console.log(\"视图渲染失败...\"); &#125; &#125;); &#125; onToggleForm()&#123; this.setState(&#123; formDisplayed : !this.state.formDisplayed &#125;); &#125; onNewNote(newNote)&#123; // console.log(JSON.stringify(newNote)); $.ajax(&#123; url : \"/addNote\", type : \"post\", contentType : \"application/json; charset=utf-8\", dataType : \"json\", data : JSON.stringify(newNote),/*反序列化，到了服务端再被bodypaser.json（）序列化*/ cache : false, success : function(notes)&#123; console.log(\"笔记添加成功！\"); notes=this.notesSort(notes); this.setState(&#123; notes:notes &#125;); &#125;.bind(this), error : function()&#123; console.log(\"失败...\"); &#125; &#125;); &#125; onDeleteNote(date)&#123;/*根据日期来删除笔记*/ var delete_date=&#123; date : date &#125;; console.log(JSON.stringify(delete_date)); $.ajax(&#123; url : \"/deleteNote\", type : \"post\", contentType : \"application/json; charset=utf-8\", dataType : \"json\", data : JSON.stringify(delete_date), cache : false, success : function(notes)&#123; console.log(\"笔记已经被删除！\"); notes=this.notesSort(notes); this.setState(&#123; notes: notes &#125;); &#125;.bind(this), error : function()&#123; console.log(\"失败...\"); &#125; &#125;); &#125; notesSort(newNotes)&#123; newNotes.reverse();/*将数据库取到的notes倒序排列再显示，即后添加上去的记录在最前面显示*/ return newNotes; &#125; render()&#123; return( &lt;div className=\"container\"&gt; &lt;Notes_header onToggleForm=&#123; this.onToggleForm.bind(this) &#125;/&gt; &lt;div className=\"container_main\"&gt; &lt;Notes_form onToggleForm=&#123; this.onToggleForm.bind(this) &#125; formDisplayed=&#123; this.state.formDisplayed &#125; onNewNote=&#123; this.onNewNote.bind(this) &#125;/&gt; &lt;Notes_list notes=&#123; this.state.notes &#125; onDeleteNote=&#123; this.onDeleteNote.bind(this) &#125;/&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Notes/&gt;,document.getElementById(\"app\")); 在这里说一下，在react中父组件和子组件之间如何进行通信呢？父组件和子组件的通信是通过传递props的方式，在props中你可以传递父组件的state，数据，还有各种定义在父组件之中的方法，子组件也通过这种方式传递给子组件的子组件，这也是一直在说的单向数据流；当父组件传递给子组件它的方法时，子组件可以通过回调来实现和父组件的通信，即给传给它的方法传递数据作为参数，父组件的方法在处理子组件传递的数据的过程中来实现与子组件的通信. 父组件的功能： 1 在组件DidMounted的时候通过ajax请求notes数据与state绑定实现首次渲染， 2 将数据，相应的方法分发给个子组件， 3 实现添加笔记的方法、删除笔记的方法、和切换表单的方法，这么说吧，几乎所有的功能都是在父组件实现的，子组件存在的意义只是在响应这些方法并给这些方法传入一些必要的参数 添加笔记的方法被触发的时候，发送ajax请求实现数据库数据的更新，再更新组件的state使之数据与后台数据保持一致，state一更新视图也会被重新渲染实现无刷新更新。 这是头部组件 123456789101112131415161718\"use strict\";import React from \"react\";class Notes_header extends React.Component&#123; render()&#123; return( &lt;div className=\"header\"&gt; &lt;div className=\"header_main\"&gt; &lt;h2&gt;React 笔记&lt;/h2&gt; &lt;input type=\"button\" value=\"添加笔记\" className=\"add_note_btn\" onClick=&#123; this.props.onToggleForm &#125;/&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Notes_header; 这个没什么好说的，前面也说过了，响应父组件的方法，这里是响应父组件的切换表单的方法。 显示笔记列表的组件 123456789101112131415161718192021\"use strict\";import React from \"react\";import Notes_item from \"./Notes_item.jsx\";class Notes_list extends React.Component&#123; render()&#123; var notes=this.props.notes; var notes_items=notes.map( (note,index) =&gt; &#123; return &lt;Notes_item key=&#123; index &#125; title=&#123; note.title &#125; description=&#123; note.description &#125; date=&#123; note.date &#125; onDeleteNote=&#123; this.props.onDeleteNote &#125;/&gt;; &#125;); return( &lt;div className=\"notes_list\"&gt; &#123; notes_items &#125; &lt;/div&gt; ); &#125;&#125;export default Notes_list; 这个组件还包含有一个更细的显示每一条笔记内容的组件,组件把父组件传给它的笔记数组，分发给它的子组件，这里是根据笔记数组的长度动态生成这些子组件的，通过数组的map方法，笔记数组有多少条记录就生成多少个这种子组件，并各自传一条记录给它们。 这是这个组件的子组件 12345678910111213141516171819202122232425262728293031323334\"use strict\";import React from \"react\";class Notes_item extends React.Component&#123; handleOver()&#123; this.refs.delete.style.display=\"block\"; &#125; handleOut()&#123; this.refs.delete.style.display=\"none\"; &#125; handleDelete()&#123; var date=this.props.date; this.props.onDeleteNote(date); &#125; render()&#123; return( &lt;div&gt; &lt;div className=\"notes_item\" onMouseOver=&#123; this.handleOver.bind(this) &#125; onMouseOut=&#123; this.handleOut.bind(this) &#125;&gt; &lt;h4&gt;&#123; this.props.title &#125;&lt;/h4&gt; &lt;p&gt;&#123; this.props.description &#125;&lt;/p&gt; &lt;input className=\"delete\" ref=\"delete\" type=\"button\" value=\"删除它\" onClick=&#123; this.handleDelete.bind(this) &#125;/&gt; &lt;span className=\"date\"&gt;&#123; this.props.date &#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Notes_item; 拿到笔记记录之后，这个小组件会把记录的每个数据项插入到合适的标签里。 最后说一下服务器端吧，用的是nodejs的express框架，这里是主路由模块的各种注册路由，就是各种api啦，react组件就是通过ajax请求这些api来得到相应的数据的，api里面通过识别请求来实现对数据库的相应操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) &#123; res.render(\"index\",&#123; title : \"react-note\" &#125;);&#125;);router.get('/init', function(req,res,next)&#123;/*请求参数，相应参数和负责把错误信息运送出来的next参数*/ var noteModel=global.dbHandle.getModel(\"note\");/*获取note数据库模型，模型能直接对数据库进行操作*/ noteModel.find(&#123;&#125;,function(err,notes)&#123; if(err)&#123; return next(err); &#125;else&#123; res.json(notes); &#125; &#125;)&#125;);router.post('/addNote', function(req,res,next)&#123; var newNote=req.body; var noteModel=global.dbHandle.getModel(\"note\"); noteModel.create(newNote,function(err)&#123; if(err)&#123; return next(err); &#125;else&#123; console.log(\"笔记已经成功写入数据库啦！！！\"); noteModel.find(&#123;&#125;,function(err,notes)&#123; if(err)&#123; console.log(\"咦？是怎么回事呢？\"); &#125;else&#123; res.json(notes); &#125; &#125;); &#125; &#125;);&#125;); router.post('/deleteNote', function(req,res,next)&#123; var delete_date=req.body.date; var noteModel=global.dbHandle.getModel(\"note\"); noteModel.remove(&#123;date : delete_date&#125;,function(err)&#123; if(err)&#123; return next(err);/*错误的话，把错误给运出来*/ &#125;else&#123; console.log(\"笔记已经被你残忍的给删除了...\"); noteModel.find(&#123;&#125;,function(err,notes)&#123; if(err)&#123; console.log(\"我也不知道怎么回事...\"); &#125;else&#123; res.json(notes); &#125; &#125;); &#125; &#125;); &#125;);module.exports = router; 用mongoose操作数据库的 dbHandle.js 12345678910111213141516171819var mongoose=require('mongoose');var models=require('./models.js');var Schema=mongoose.Schema;/*根据已经规划好的数据库模型表定义各种数据库模型，传入必要的模型骨架Schema和模型名（类型）*/for( var modelName in models )&#123; mongoose.model( modelName , new Schema( models[ modelName ] ));&#125;/*传入模型名（类型）获取到相应的模型*/module.exports=&#123; getModel : function( modelName )&#123; return _getModel( modelName ); &#125;&#125;;var _getModel=function( modelName )&#123; return mongoose.model( modelName );&#125; 总的来说这个数据库操控模块功能就是根据已经有了的数据库模型规划表生成各种实际的数据库模型，并当传入一个数据库模型名给它时，给你返回相应的数据库模型，得到数据库模型你可以去操控数据库 models.js 12345678module.exports=&#123; note : &#123; title : &#123; type : String , required : true &#125;, description : &#123; type : String , required : true &#125;, date : &#123; type : String , required : true &#125; &#125;&#125;; 这是webpack的配置 1234567891011121314151617181920212223//webpack.config.jsvar path=require(\"path\");module.exports=&#123; entry: \"./public/javascripts/entry.js\", output: &#123; path: path.join(__dirname,\"./public/out\"), //打包输出的路径 filename: \"bundle.js\", //打包后的名字 publicPath: \"./public/out/\" &#125;, //*大于8KB的图片不会被打包，所以一般会被打包的都是一些css文件引入的icon图标或者logo什么的 //在对模块捆绑打包的过程中会对文件的后缀名进行检测，然后进行相应的预处理 module: &#123; loaders: [ &#123;test: /\\.js$/, loader: \"babel\",query: &#123;presets: ['react','es2015']&#125;&#125;, /*es6 to es5*/ &#123;test: /\\.jsx$/,loader: 'babel', query: &#123;presets: ['react', 'es2015']&#125;&#125;, /*jsx to js,es5 to es6*/ &#123;test: /\\.css$/, loader: \"style!css\"&#125;, /*css to css*/ &#123;test: /\\.(jpg|png|otf)$/, loader: \"url?limit=8192\"&#125;, /*images 打包*/ &#123;test: /\\.scss$/, loader: \"style!css!sass\"&#125; /*sass to css*/ ] &#125;&#125;; webpack的各种加载器本身是不具备各种转译功能的，比如babel加载器，它自己是不能转译jsx文件或者es6的，但是当它检测到jsx或者es6代码的存在的时候，会帮你去调用babel-core还有相应的预设来转译它们。 我用sass写的样式，所以配置里用了sass加载器，记得要去下载个node-sass模块才能支持sass的转译. 这里应该是总结 =&gt;没有总结","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"javascript基于原型实现面向对象","slug":"javascript基于原型实现面向对象 ","date":"2015-12-09T14:36:00.000Z","updated":"2016-11-06T08:13:18.044Z","comments":true,"path":"2015/12/09/javascript基于原型实现面向对象 /","link":"","permalink":"http://yoursite.com/2015/12/09/javascript基于原型实现面向对象 /","excerpt":"","text":"传统的OO语言有类的概念，基于类实现面向对象，但javascript（ES5）却是基于原型实现的面向对象。 那…原型是？ 我们创建的每一个函数都会有一个原型（prototype）属性，这个属性是一个指针，指向函数的原型（prototype）对象。使用原型对象可以让构造函数的实例对象共享原型对象包含的属性和方法，而不会像工厂模式或者构造函数模式那样，方法本应该是可以是通用的，可是每一个创建的对象实例都要各自复制一份。 1234567891011function People(name)&#123; this.name=name; this.sayName=function()&#123; console.log(\"Hi! my name is \"+this.name); &#125;;&#125;var Kelly=new People(\"Kelly\");var AsenZ=new People(\"AsenZ\");console.log(Kelly.sayName==AsenZ.sayName); //false 但使用原型模式的话，同一个方法是被不同对象实例所引用的，上面的结果会返回ture。 1234567891011function People(name)&#123; this.name=name;&#125;People.prototype.sayName=function()&#123; console.log(\"Hi! my name is \"+this.name);&#125;;var Kelly=new People(\"Kelly\");var AsenZ=new People(\"AsenZ\");console.log(Kelly.sayName==AsenZ.sayName); //true 构造函数实例化的过程中发生了什么？ 构造函数通过new操作符实例化的每一个对象，都会生成一个指向构造函数原型对象的指针，不过在这里不是prototype（构造函数通过prototype指针指向原型对象），而是[[ prototype ]], 同时构造函数内部的this指针会绑定到该对象实例上。 构造函数内部绑定在this指针下的所有属性或者方法会被复制下来，作为实例对象的一部分，但是呢原型中定义的属性和方法仍是属于原型自身的，不归对象实例所有。对象只是引用。对象在调用一个属性或者方法时，如果在构造函数内部没有相应的定义，则会通过[[prototype]]指针去原型对象中寻找。 继承 — 借用构造函数 如果需要继承构造函数内部this指针所绑定的所有属性和方法的话，可以在子构造函数中使用call方法，call方法的第一个参数会传入一个对象，这个对象会用来替换调用call方法的方法中的this，所以我们call方法的第一个参数可以传入子构造函数内部的this指针。 但是这种方法却继承不了原型内部的属性和方法。 12345678910111213141516function People(name)&#123; this.name=name;&#125;People.prototype.sayName=function()&#123; console.log(\"Hi! my name is \"+this.name);&#125;;function Boy(name)&#123; People.call(this,name);&#125;var Kelly=new Boy(\"Kelly\");console.log(Kelly.name); //Kellyconsole.log(Kelly.sayName); //undefined 可是如果需要继承原型对象的内部属性和方法的话呢？— 组合继承（借用构造函数+原型链） 123456789101112131415161718function People(name)&#123; this.name=name;&#125;People.prototype.sayName=function()&#123; console.log(\"Hi! my name is \"+this.name);&#125;;function Boy(name)&#123; People.call(this,name);&#125;Boy.prototype=new People();Boy.prototype.constructor=Boy;var Kelly=new Boy(\"Kelly\");console.log(Kelly.name); //KellyKelly.sayName(); //Hi! my name is Kelly 还有不少其他的实现继承的方法，不过感觉思路差不了多少的，这一篇总结主要是为了加深一下自己对原型的理解。 虽然说有了babel，现在ES6已经可以放开的使用了！class定义类，extends实现继承不能再爽，但是这些新特性也不过是语法糖，底层的原理还是离不开最基本的原型。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"使用 CSS 画出对话框","slug":"用css画出对话框","date":"2015-10-16T01:41:00.000Z","updated":"2016-11-06T07:59:49.827Z","comments":true,"path":"2015/10/16/用css画出对话框/","link":"","permalink":"http://yoursite.com/2015/10/16/用css画出对话框/","excerpt":"","text":"&#160; &#160; &#160; &#160;这是一道2014百度秋招的笔试题，解题关键在于如何用css实现出那个小三角形，在说实现方法之前让我们先来看一小段代码理解一下border属性吧。 1234567891011121314151617&lt;/style&gt; #demo1&#123; width: 0; height: 0; border-top: 50px solid #f69; border-left: 50px solid #000; border-bottom: 50px solid red; border-right: 50px solid yellow; &#125; &lt;/style&gt;&lt;body&gt; &lt;div id=\"demo1\"&gt;&lt;/div&gt; &lt;/body&gt; 这是在浏览器打开后的效果 因为div的宽高都被设置为零了，所以四个颜色的小三角形其实就代表着四条边当我们把其中一条边的颜色设置为透明transparent时，这个div就变成这个样子了： 缺了一个小三角形，因为它被设置为透明了，说明它确实是一条边。那这样的话，我们接下来要是再把其中的两条边颜色给设置为透明，是不是就能得到一个小三角形了呢？ 看，按这种办法四个方向的小三角形我们都可以实现出来了。但是这样还不够，看一下题目中的小三角形，它是有两条边的颜色和它内部的颜色不一样的，而我们实现的小三角形都是一个颜色。那怎么办？给我们的小三角形加border-color吗？但别忘了小三角形本身就是一条边哦，给它加边框颜色只会是把整个三角形的颜色替换掉。 不过可以用这种小技巧：实现出一个透明的三角形，让它覆盖掉黑色三角形的内部，只留边框，这样不就能得到上面的效果了？! 实现小三角形的时候，我使用了伪类：before和：after，这样可以减少不必要的div标签。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=utf-8&gt;&lt;title&gt;demo&lt;/title&gt;&lt;/head&gt; &lt;style&gt;#demo&#123; width:100px; height:100px; border:2px solid #000;&#125;#demo:before&#123; content:''; display:block; width:0; height:0; position:relative; top:10px; left:100px; border-left:9px solid #000; border-top:7px solid transparent; border-bottom:7px solid transparent;&#125;#demo:after&#123; content:''; display:block; width:0; height:0; position:relative; top:-2px; left:100px; border-left:7px solid #fff; border-top:5px solid transparent; border-bottom:5px solid transparent;&#125; &lt;/style&gt;&lt;body&gt; &lt;div id='demo'&gt;&lt;/div&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 效果图：","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"keywords":[]}]}